<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Domin√≥ Suizo PRO ‚Äì 2vs2 Offline</title>
  <style>
    :root { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial; }
    body { margin:0; background:#0b1220; color:#e8eefc; }
    header { padding:16px 18px; background:#121a2b; position:sticky; top:0; border-bottom:1px solid #22304f; z-index:10; }
    header h1 { margin:0; font-size:18px; }
    main { padding:16px 18px; max-width:1200px; margin:0 auto; }
    .grid { display:grid; gap:12px; grid-template-columns:1fr; }
    @media (min-width: 900px){ .grid { grid-template-columns: 1.1fr 1fr; } }
    .card { background:#121a2b; border:1px solid #22304f; border-radius:14px; padding:14px; }
    .card h2 { margin:0 0 10px; font-size:15px; }
    textarea { width:100%; min-height:160px; background:#0b1220; color:#e8eefc; border:1px solid #22304f; border-radius:10px; padding:10px; resize:vertical; }
    input, select { background:#0b1220; color:#e8eefc; border:1px solid #22304f; border-radius:10px; padding:8px 10px; }
    .row { display:flex; gap:10px; flex-wrap:wrap; align-items:center; }
    button { background:#2b65ff; color:white; border:0; border-radius:10px; padding:10px 12px; cursor:pointer; font-weight:650; }
    button.secondary { background:#1b2847; border:1px solid #22304f; }
    button.danger { background:#d12b2b; }
    button:disabled { opacity:.55; cursor:not-allowed; }
    .muted { color:#9fb1db; font-size:12px; }
    .pill { display:inline-block; padding:3px 8px; border:1px solid #22304f; border-radius:999px; font-size:12px; color:#cfe0ff; }
    .flex-between { display:flex; justify-content:space-between; gap:12px; align-items:center; }
    .notice { padding:10px; border:1px solid #22304f; border-radius:12px; background:#0b1220; }
    .notice.warn { border-color:#d12b2b; color:#ffd0d0; }
    .matches { display:flex; flex-direction:column; gap:10px; }
    .match { border:1px solid #22304f; border-radius:12px; padding:10px; background:#0f1830; display:grid; grid-template-columns:1fr; gap:10px; }
    @media (min-width: 750px){ .match { grid-template-columns: 1.7fr 1fr .9fr; } }
    .names { display:flex; flex-direction:column; gap:6px; }
    .line { display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
    .line b { font-size:14px; }
    .vs { color:#9fb1db; font-size:12px; margin:4px 0; }
    .scores { display:flex; gap:10px; align-items:center; flex-wrap:wrap; }
    .scores label { display:flex; gap:6px; align-items:center; font-size:12px; color:#cfe0ff; }
    .winner { display:flex; align-items:center; justify-content:flex-end; }
    table { width:100%; border-collapse:collapse; overflow:hidden; border-radius:12px; }
    th, td { border-bottom:1px solid #22304f; padding:10px; text-align:left; font-size:13px; }
    th { background:#0f1830; }
    .kbd { font-family: ui-monospace, SFMono-Regular, Menlo, monospace; font-size:12px; padding:2px 6px; border:1px solid #22304f; border-radius:8px; background:#0b1220; color:#cfe0ff; }
    .modal-backdrop{ position:fixed; inset:0; background:rgba(0,0,0,.55); display:none; align-items:center; justify-content:center; z-index:50; padding:14px; }
    .modal{ width:min(780px, 100%); background:#121a2b; border:1px solid #22304f; border-radius:16px; overflow:hidden; }
    .modal header{ position:unset; background:#0f1830; border-bottom:1px solid #22304f; }
    .modal .content{ padding:14px; }
    .modal .content h3{ margin:0 0 8px; font-size:15px; }
    .modal .content ul{ margin:8px 0 0 18px; padding:0; }
    .modal .content li{ margin:6px 0; }
    .modal .actions{ padding:12px 14px; border-top:1px solid #22304f; display:flex; justify-content:flex-end; gap:10px; background:#0f1830; }
    .modal-show{ display:flex; }
    .mesa-wrap{ display:none; }
    .mesa-card{ background:#0f1830; border:1px solid #22304f; border-radius:16px; padding:14px; }
    .mesa-big{ font-size:18px; font-weight:800; }
    .mesa-sub{ margin-top:6px; color:#cfe0ff; font-size:14px; }
    .mesa-score{ display:flex; gap:10px; flex-wrap:wrap; margin-top:12px; }
    .mesa-score input{ width:120px; font-size:18px; padding:12px 12px; }
    .mesa-actions{ display:flex; gap:10px; flex-wrap:wrap; margin-top:12px; }
    .mesa-note{ margin-top:10px; color:#9fb1db; font-size:12px; }
  </style>
</head>
<body>
<header class="flex-between">
  <h1>üÅ´ Domin√≥ Suizo PRO ‚Äì 2vs2 (Offline)</h1>
  <div class="row">
    <span class="pill" id="roundPill">Ronda: 0/5</span>
    <span class="pill" id="arbPill">√Årbitro: OFF</span>
    <button class="secondary" id="btnMesaMode">Modo Mesa</button>
    <button class="secondary" id="btnExport">Export PRO</button>
    <button class="danger" id="btnReset">Reset</button>
  </div>
</header>

<main class="grid">
  <section class="card">
    <h2>Jugadores</h2>
    <p class="muted">
      1 jugador por l√≠nea. Ranking: <b>Ganadas</b> ‚Üí <b>PF</b> ‚Üí <b>DIF</b>. <b>No empates</b>. <b>5 rondas</b>.<br/>
      Si NO es m√∫ltiplo de 4: <b>Banco rotativo justo</b> (modo B).
    </p>

    <textarea id="playersInput" placeholder="Ej:
Juan
Pedro
Luis
Ana
Carlos
Miguel
..."></textarea>

    <div class="row" style="margin-top:10px;">
      <button id="btnLoadPlayers">Guardar jugadores</button>
      <button class="secondary" id="btnGenR1">Generar Ronda 1</button>
      <button class="secondary" id="btnGenNext">Siguiente Ronda (Suizo PRO)</button>
      <span class="muted small" id="playersCount"></span>
    </div>

    <div class="notice" style="margin-top:12px;">
      <div class="row">
        <span class="pill">Modo B</span>
        <span class="muted">Banco rotativo justo: descansan 1‚Äì3 si no es m√∫ltiplo de 4.</span>
      </div>
      <div class="row" style="margin-top:8px;">
        <span class="pill">√Årbitro</span>
        <span class="muted">Bloquea edici√≥n de rondas pasadas. Act√≠valo con PIN local.</span>
        <button class="secondary" id="btnArbToggle">Activar/Desactivar √°rbitro</button>
        <button class="secondary" id="btnArbSetPin">Definir PIN</button>
      </div>
      <div class="row" style="margin-top:8px;">
        <span class="pill">Tip</span>
        <span class="muted">Si ves cache viejo en iPhone: abre con <span class="kbd">?v=999</span>.</span>
      </div>
    </div>

    <div id="statusBox" class="notice" style="margin-top:12px; display:none;"></div>
  </section>

  <section class="card">
    <div class="flex-between">
      <h2>Ronda actual</h2>
      <button id="btnSaveScores">Guardar puntos</button>
    </div>

    <div class="mesa-wrap" id="mesaWrap">
      <div class="mesa-card">
        <div class="row" style="justify-content:space-between; align-items:flex-start;">
          <div>
            <div class="mesa-big" id="mesaTitle">Mesa</div>
            <div class="mesa-sub" id="mesaTeams">A+B vs C+D</div>
          </div>
          <div class="row">
            <span class="pill" id="mesaIdxPill">Mesa 1/1</span>
          </div>
        </div>

        <div class="mesa-score">
          <label class="scores"><span class="pill">A</span>
            <input id="mesaPtsA" type="number" min="0" step="1" placeholder="Pts A" />
          </label>
          <label class="scores"><span class="pill">B</span>
            <input id="mesaPtsB" type="number" min="0" step="1" placeholder="Pts B" />
          </label>
        </div>

        <div class="mesa-actions">
          <button class="secondary" id="mesaPrev">‚óÄ Anterior</button>
          <button class="secondary" id="mesaNext">Siguiente ‚ñ∂</button>
          <button id="mesaSaveOne">Guardar esta mesa</button>
        </div>

        <div class="mesa-note">Ideal en iPhone para anotar r√°pido mesa por mesa.</div>
      </div>
      <div style="margin-top:10px;">
        <button class="secondary" id="mesaExit">Salir modo mesa</button>
      </div>
    </div>

    <div class="matches" id="matches"></div>
    <p class="muted small">Puntos por equipo. El ganador sale por puntos. <b>No empates</b>.</p>
  </section>

  <section class="card" style="grid-column:1/-1;">
    <div class="flex-between">
      <h2>Tabla (toca un jugador para auditor√≠a)</h2>
      <span class="muted small">Orden: Ganadas ‚Üí PF ‚Üí DIF</span>
    </div>
    <div style="overflow:auto; border-radius:12px; border:1px solid #22304f;">
      <table>
        <thead>
          <tr>
            <th>#</th><th>Jugador</th><th>PJ</th><th>G</th><th>P</th><th>PF</th><th>PC</th><th>DIF</th><th>Ganadas</th><th>Descansos</th>
          </tr>
        </thead>
        <tbody id="tableBody"></tbody>
      </table>
    </div>
  </section>

  <section class="card" style="grid-column:1/-1;">
    <div class="flex-between">
      <h2>Diagn√≥stico (PRO)</h2>
      <span class="muted small">parejas/rivales repetidos + banco</span>
    </div>
    <div id="diagBox" class="notice"></div>
  </section>
</main>

<div class="modal-backdrop" id="modalBack">
  <div class="modal" role="dialog" aria-modal="true">
    <header class="flex-between">
      <h1 id="modalTitle" style="font-size:16px;">Jugador</h1>
      <div class="row">
        <button class="secondary" id="modalCloseTop">Cerrar</button>
      </div>
    </header>
    <div class="content" id="modalContent"></div>
    <div class="actions">
      <button class="secondary" id="modalClose">Cerrar</button>
    </div>
  </div>
</div>

<script>
/* ====== BLOQUE 1 termina aqu√≠. NO cierres </script> ni </body> ni </html> todav√≠a ====== */
/* =================== Config =================== */
const MAX_ROUNDS = 5;

/* Emparejamiento: pesos */
const W_TEAM_REPEAT = 250;
const W_VS_REPEAT   = 60;
const W_TABLE_DRIFT = 4;

/* Optimizaci√≥n */
const OPT_TRIES = 600;
const OPT_WINDOW = 12;

/* =================== Storage =================== */
const STORAGE_KEY = "domino_suizo_2v2_offline_PRO_FULL_v2";
const PIN_KEY = "domino_suizo_arb_pin_v1";

/* =================== Estado =================== */
const state = {
  players: [],
  rounds: [],
  benchHistory: {},
  _lastBench: null,
  mesaMode: false,
  mesaIdx: 0,
  arbOn: false
};

function saveState(){ localStorage.setItem(STORAGE_KEY, JSON.stringify(state)); }
function loadState(){
  const raw = localStorage.getItem(STORAGE_KEY);
  if(!raw) return;
  try{
    const s = JSON.parse(raw);
    if(s && Array.isArray(s.players) && Array.isArray(s.rounds)){
      Object.assign(state, s);
      state.benchHistory = s.benchHistory || {};
      state._lastBench = s._lastBench || null;
      state.mesaMode = !!s.mesaMode;
      state.mesaIdx = Number.isFinite(s.mesaIdx) ? s.mesaIdx : 0;
      state.arbOn = !!s.arbOn;
    }
  }catch{}
}
function resetAll(){
  if(!confirm("¬øSeguro que quieres borrar todo el torneo?")) return;
  state.players = [];
  state.rounds = [];
  state.benchHistory = {};
  state._lastBench = null;
  state.mesaMode = false;
  state.mesaIdx = 0;
  state.arbOn = false;
  saveState();
  renderAll();
}

/* =================== Util =================== */
function escapeHtml(s){
  return String(s).replace(/[&<>"']/g, m => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#039;'}[m]));
}
function uniqNonEmptyLines(text){
  const lines = text.split(/\r?\n/).map(s=>s.trim()).filter(Boolean);
  const seen = new Set();
  const out = [];
  for(const n of lines){
    const k = n.toLowerCase();
    if(!seen.has(k)){ seen.add(k); out.push(n); }
  }
  return out;
}
function shuffle(arr){
  const a = arr.slice();
  for(let i=a.length-1;i>0;i--){
    const j = Math.floor(Math.random()*(i+1));
    [a[i],a[j]]=[a[j],a[i]];
  }
  return a;
}
function currentRoundNumber(){
  return state.rounds.reduce((m,x)=>Math.max(m,x.round),0);
}
function matchesInRound(rn){
  return state.rounds.filter(m=>m.round===rn).sort((a,b)=>a.table-b.table);
}
function pairKey(a,b){ a=String(a); b=String(b); return (a<b)?`${a}|${b}`:`${b}|${a}`; }
function teamKey(a1,a2){ return pairKey(a1,a2); }
function teamsVsKey(tA, tB){ return (tA<tB)?`${tA}||${tB}`:`${tB}||${tA}`; }
function clamp(x,min,max){ return Math.max(min, Math.min(max, x)); }

/* =================== Standings =================== */
function computeStandings(){
  const stats = new Map();
  for(const p of state.players){
    stats.set(p,{player:p,PJ:0,G:0,P:0,PF:0,PC:0,DIF:0,PTS:0,bench:(state.benchHistory[p]||0)});
  }

  const teammateUsed = new Map();
  const vsUsed = new Map();

  for(const m of state.rounds){
    if(!stats.has(m.A1)||!stats.has(m.A2)||!stats.has(m.B1)||!stats.has(m.B2)) continue;

    const tA = teamKey(m.A1,m.A2);
    const tB = teamKey(m.B1,m.B2);
    const vK = teamsVsKey(tA,tB);

    teammateUsed.set(tA, (teammateUsed.get(tA)||0)+1);
    teammateUsed.set(tB, (teammateUsed.get(tB)||0)+1);
    vsUsed.set(vK, (vsUsed.get(vK)||0)+1);

    [m.A1,m.A2,m.B1,m.B2].forEach(p=>stats.get(p).PJ++);

    const a = Number(m.ptsA);
    const b = Number(m.ptsB);
    if(!Number.isFinite(a) || !Number.isFinite(b)) continue;
    if(a===b) continue;

    if(a>b){
      [m.A1,m.A2].forEach(p=>{ stats.get(p).G++; stats.get(p).PTS++; });
      [m.B1,m.B2].forEach(p=>{ stats.get(p).P++; });
    } else {
      [m.B1,m.B2].forEach(p=>{ stats.get(p).G++; stats.get(p).PTS++; });
      [m.A1,m.A2].forEach(p=>{ stats.get(p).P++; });
    }

    [m.A1,m.A2].forEach(p=>{ stats.get(p).PF += a; stats.get(p).PC += b; });
    [m.B1,m.B2].forEach(p=>{ stats.get(p).PF += b; stats.get(p).PC += a; });
  }

  for(const s of stats.values()) s.DIF = s.PF - s.PC;

  const table = Array.from(stats.values()).sort((x,y)=>{
    if(y.PTS !== x.PTS) return y.PTS - x.PTS;
    if(y.PF  !== x.PF ) return y.PF  - x.PF;
    if(y.DIF !== x.DIF) return y.DIF - x.DIF;
    return x.player.localeCompare(y.player);
  });

  const ranked = table.map(x=>x.player);
  const rankPos = new Map(ranked.map((p,i)=>[p,i]));
  return { table, ranked, rankPos, teammateUsed, vsUsed };
}

/* =================== Validaci√≥n =================== */
function canGenerateNextRound(){
  if(state.players.length < 4) return false;
  const rn = currentRoundNumber();
  if(rn===0) return true;
  const ms = matchesInRound(rn);
  for(const m of ms){
    const a = Number(m.ptsA), b = Number(m.ptsB);
    if(!Number.isFinite(a) || !Number.isFinite(b)) return false;
    if(a===b) return false;
  }
  return true;
}

/* =================== Banco rotativo justo =================== */
function pickBench(pool, need){
  const counts = state.benchHistory || {};
  const scored = pool.map(n=>({n, c:(counts[n]||0)})).sort((a,b)=>a.c-b.c);
  const bench = [];
  let i=0;
  while(bench.length<need && i<scored.length){
    const minC = scored[i].c;
    const same = [];
    while(i<scored.length && scored[i].c===minC){
      same.push(scored[i].n); i++;
    }
    for(const n of shuffle(same)){
      if(bench.length<need) bench.push(n);
    }
  }
  return bench;
}
function markBench(bench){
  for(const n of bench) state.benchHistory[n] = (state.benchHistory[n]||0) + 1;
}

/* =================== √Årbitro PIN =================== */
function getPin(){ return localStorage.getItem(PIN_KEY) || ""; }
function setPin(pin){ localStorage.setItem(PIN_KEY, pin); }
function ensureArb(){
  const pin = getPin();
  if(!pin){ alert("Primero define un PIN (bot√≥n 'Definir PIN')."); return false; }
  const input = prompt("PIN √°rbitro:");
  if(input === null) return false;
  if(input !== pin){ alert("PIN incorrecto."); return false; }
  return true;
}
function toggleArb(){
  if(state.arbOn){
    state.arbOn = false;
    saveState(); renderAll();
    return;
  }
  if(ensureArb()){
    state.arbOn = true;
    saveState(); renderAll();
  }
}
function setArbPin(){
  const old = getPin();
  if(old){
    const ok = confirm("Ya existe un PIN. ¬øQuieres cambiarlo?");
    if(!ok) return;
    const inputOld = prompt("PIN actual:");
    if(inputOld === null) return;
    if(inputOld !== old){ alert("PIN incorrecto."); return; }
  }
  const pin = prompt("Define PIN (4‚Äì8 d√≠gitos recomendado):");
  if(pin === null) return;
  const clean = String(pin).trim();
  if(clean.length < 4){ alert("PIN muy corto."); return; }
  setPin(clean);
  alert("PIN guardado ‚úÖ");
}

/* =================== Emparejamiento PRO =================== */
function bestSplitOf4(group, histTeamCount, histVsCount){
  const [a,b,c,d] = group;
  const options = [
    {A:[a,b], B:[c,d]},
    {A:[a,c], B:[b,d]},
    {A:[a,d], B:[b,c]},
  ];
  let best = null;
  for(const opt of options){
    const tA = teamKey(opt.A[0], opt.A[1]);
    const tB = teamKey(opt.B[0], opt.B[1]);
    const vK = teamsVsKey(tA, tB);

    const repTeam = (histTeamCount.get(tA)||0) + (histTeamCount.get(tB)||0);
    const repVs = (histVsCount.get(vK)||0);
    const score = repTeam * W_TEAM_REPEAT + repVs * W_VS_REPEAT;

    if(!best || score < best.score){
      best = { ...opt, tA, tB, vK, score };
    }
  }
  return best;
}

function scoreGrouping(groups, histTeamCount, histVsCount, rankPos){
  let total = 0;
  for(const g of groups){
    const pick = bestSplitOf4(g, histTeamCount, histVsCount);
    total += pick.score;

    const positions = g.map(p=>rankPos.get(p) ?? 999999);
    const avg = positions.reduce((a,b)=>a+b,0) / positions.length;
    const drift = positions.reduce((s,x)=>s + Math.abs(x-avg), 0);
    total += drift * W_TABLE_DRIFT;
  }
  return total;
}

function optimizeGroups(pool, histTeamCount, histVsCount, rankPos){
  let bestGroups = [];
  for(let i=0;i<pool.length;i+=4) bestGroups.push(pool.slice(i,i+4));
  let bestScore = scoreGrouping(bestGroups, histTeamCount, histVsCount, rankPos);

  const base = pool.slice();
  const n = base.length;

  function groupsFromFlat(flat){
    const gs = [];
    for(let i=0;i<flat.length;i+=4) gs.push(flat.slice(i,i+4));
    return gs;
  }

  for(let t=0; t<OPT_TRIES; t++){
    const flat = base.slice();
    const swaps = 2 + (t % 4);

    for(let k=0;k<swaps;k++){
      const i = Math.floor(Math.random()*n);
      const j = clamp(i + (Math.floor(Math.random()*(2*OPT_WINDOW+1)) - OPT_WINDOW), 0, n-1);
      if(i===j) continue;
      [flat[i], flat[j]] = [flat[j], flat[i]];
    }

    const gs = groupsFromFlat(flat);
    const s = scoreGrouping(gs, histTeamCount, histVsCount, rankPos);
    if(s < bestScore){
      bestScore = s;
      bestGroups = gs.map(g=>g.slice());
      if(bestScore === 0) break;
    }
  }
  return bestGroups;
}

function generateRound1(){
  if(state.players.length < 4) return alert("Necesitas m√≠nimo 4 jugadores.");
  if(currentRoundNumber() > 0) return alert("Ya hay rondas. Usa 'Siguiente Ronda'.");
  const ranked = shuffle(state.players);
  addNewRoundFromRanked(ranked);
}

function generateNextRound(){
  if(currentRoundNumber() >= MAX_ROUNDS) return alert("Ya se jugaron 5 rondas ‚úÖ");
  if(!canGenerateNextRound()) return alert("Completa puntos de la ronda actual (sin empates).");
  const { ranked, teammateUsed, vsUsed } = computeStandings();
  addNewRoundFromRanked(ranked, teammateUsed, vsUsed);
}

function addNewRoundFromRanked(ranked, histTeamCountMap, histVsCountMap){
  let pool = ranked.slice();

  let bench = [];
  if(pool.length % 4 !== 0){
    const need = pool.length % 4;
    bench = pickBench(pool, need);
    const setB = new Set(bench);
    pool = pool.filter(p=>!setB.has(p));
    markBench(bench);
  }

  const { rankPos, teammateUsed, vsUsed } = computeStandings();
  const histTeamCount = histTeamCountMap || teammateUsed;
  const histVsCount = histVsCountMap || vsUsed;

  const groups = optimizeGroups(pool, histTeamCount, histVsCount, rankPos);

  const rn = currentRoundNumber() + 1;
  let tableNo = 1;

  const localTeam = new Map(histTeamCount);
  const localVs = new Map(histVsCount);

  for(const g of groups){
    const pick = bestSplitOf4(g, localTeam, localVs);

    localTeam.set(pick.tA, (localTeam.get(pick.tA)||0) + 1);
    localTeam.set(pick.tB, (localTeam.get(pick.tB)||0) + 1);
    localVs.set(pick.vK, (localVs.get(pick.vK)||0) + 1);

    state.rounds.push({
      round: rn, table: tableNo++,
      A1: pick.A[0], A2: pick.A[1],
      B1: pick.B[0], B2: pick.B[1],
      ptsA:"", ptsB:""
    });
  }

  state._lastBench = bench.length ? { round: rn, players: bench.slice() } : null;
  state.mesaIdx = 0;

  saveState();
  renderAll();
}

/* =================== Auditor√≠a por jugador =================== */
function getPlayerHistory(player){
  const hist = [];
  for(const m of state.rounds){
    const inA = (m.A1===player || m.A2===player);
    const inB = (m.B1===player || m.B2===player);
    if(!inA && !inB) continue;

    const team = inA ? [m.A1,m.A2] : [m.B1,m.B2];
    const opp = inA ? [m.B1,m.B2] : [m.A1,m.A2];
    const ptsMe = inA ? m.ptsA : m.ptsB;
    const ptsOpp = inA ? m.ptsB : m.ptsA;

    let result = "Pendiente";
    const a = Number(ptsMe), b = Number(ptsOpp);
    if(Number.isFinite(a) && Number.isFinite(b) && a!==b){
      result = (a>b) ? "Gan√≥" : "Perdi√≥";
    } else if(Number.isFinite(a) && Number.isFinite(b) && a===b){
      result = "Empate (NO permitido)";
    }

    hist.push({
      round: m.round, table: m.table,
      teammate: team[0]===player ? team[1] : team[0],
      opponents: opp,
      ptsMe, ptsOpp, result
    });
  }
  hist.sort((x,y)=>x.round-y.round || x.table-y.table);
  return hist;
}

function openAudit(player){
  const { table } = computeStandings();
  const s = table.find(x=>x.player===player);
  const hist = getPlayerHistory(player);

  const teammateCount = new Map();
  const oppCount = new Map();
  for(const h of hist){
    teammateCount.set(h.teammate, (teammateCount.get(h.teammate)||0)+1);
    for(const o of h.opponents){
      oppCount.set(o, (oppCount.get(o)||0)+1);
    }
  }
  const repTeam = Array.from(teammateCount.entries()).filter(([,c])=>c>1).sort((a,b)=>b[1]-a[1]);
  const repOpp = Array.from(oppCount.entries()).filter(([,c])=>c>1).sort((a,b)=>b[1]-a[1]);

  els.modalTitle.textContent = `Auditor√≠a: ${player}`;
  const parts = [];
  if(s){
    parts.push(`<div class="row" style="gap:8px; margin-bottom:8px;">
      <span class="pill">G</span><b>${s.PTS}</b>
      <span class="pill">PF</span><b>${s.PF}</b>
      <span class="pill">DIF</span><b>${s.DIF}</b>
      <span class="pill">PJ</span><b>${s.PJ}</b>
      <span class="pill">Descansos</span><b>${s.bench}</b>
    </div>`);
  }

  parts.push(`<h3>Partidas</h3>`);
  if(!hist.length){
    parts.push(`<div class="muted">A√∫n no ha jugado.</div>`);
  } else {
    parts.push(`<ul class="muted small">` + hist.map(h=>{
      return `<li><b>R${h.round}</b> Mesa ${h.table}: con <b>${escapeHtml(h.teammate)}</b> vs <b>${escapeHtml(h.opponents[0])}</b> + <b>${escapeHtml(h.opponents[1])}</b> ‚Äî <b>${escapeHtml(String(h.ptsMe||""))}</b>‚Äì<b>${escapeHtml(String(h.ptsOpp||""))}</b> (${escapeHtml(h.result)})</li>`;
    }).join("") + `</ul>`);
  }

  parts.push(`<h3 style="margin-top:12px;">Repeticiones</h3>`);
  parts.push(`<div class="muted small"><b>Parejas repetidas:</b> ${repTeam.length ? repTeam.slice(0,8).map(([n,c])=>`${escapeHtml(n)} (${c})`).join(", ") : "Ninguna ‚úÖ"}</div>`);
  parts.push(`<div class="muted small" style="margin-top:6px;"><b>Rivales repetidos:</b> ${repOpp.length ? repOpp.slice(0,8).map(([n,c])=>`${escapeHtml(n)} (${c})`).join(", ") : "Ninguno ‚úÖ"}</div>`);

  els.modalContent.innerHTML = parts.join("");
  els.modalBack.classList.add("modal-show");
}
function closeModal(){
  els.modalBack.classList.remove("modal-show");
}
/* =================== Diagn√≥stico (PRO) =================== */
function buildDiagnostics(){
  const teamCount = new Map();
  const vsCount = new Map();

  for(const m of state.rounds){
    const tA = teamKey(m.A1,m.A2);
    const tB = teamKey(m.B1,m.B2);
    const vK = teamsVsKey(tA,tB);

    teamCount.set(tA, (teamCount.get(tA)||0)+1);
    teamCount.set(tB, (teamCount.get(tB)||0)+1);
    vsCount.set(vK, (vsCount.get(vK)||0)+1);
  }

  const repTeams = Array.from(teamCount.entries()).filter(([,c])=>c>1).sort((a,b)=>b[1]-a[1]);
  const repVs = Array.from(vsCount.entries()).filter(([,c])=>c>1).sort((a,b)=>b[1]-a[1]);

  const topTeams = repTeams.slice(0,8).map(([k,c])=>`<li><b>${escapeHtml(k.replace("|"," + "))}</b> ‚Üí ${c} veces</li>`).join("");
  const topVs = repVs.slice(0,8).map(([k,c])=>{
    const parts = k.split("||");
    return `<li><b>${escapeHtml(parts[0].replace("|"," + "))}</b> vs <b>${escapeHtml(parts[1].replace("|"," + "))}</b> ‚Üí ${c} veces</li>`;
  }).join("");

  const benchSorted = state.players.map(p=>({p, c:(state.benchHistory[p]||0)})).sort((a,b)=>b.c-a.c);
  const benchTop = benchSorted.slice(0,12).map(x=>`${escapeHtml(x.p)} (${x.c})`).join(", ");

  const rn = currentRoundNumber();
  const benchThis = state._lastBench && state._lastBench.round===rn ? state._lastBench.players : [];

  return `
    <div class="row" style="margin-bottom:8px;">
      <span class="pill">Repeticiones</span>
      <span class="muted">El optimizador minimiza parejas primero, luego rivales.</span>
    </div>

    <div class="row" style="gap:18px; align-items:flex-start;">
      <div style="flex:1; min-width:260px;">
        <div class="muted"><b>Parejas repetidas</b> (top)</div>
        <ul class="muted">${topTeams || "<li>Ninguna repetida ‚úÖ</li>"}</ul>
      </div>
      <div style="flex:1; min-width:260px;">
        <div class="muted"><b>Rivales repetidos</b> (top)</div>
        <ul class="muted">${topVs || "<li>Ning√∫n cruce repetido ‚úÖ</li>"}</ul>
      </div>
    </div>

    <div class="row" style="margin-top:10px;">
      <span class="pill">Banco</span>
      <span class="muted">M√°s descansos: ${benchTop || "‚Äî"}</span>
    </div>

    <div class="row" style="margin-top:6px;">
      <span class="pill">Esta ronda</span>
      <span class="muted">${benchThis.length ? ("Descansan: " + benchThis.map(escapeHtml).join(", ")) : "Sin banco"}</span>
    </div>
  `;
}

/* =================== Export PRO =================== */
function q(s){
  const t = String(s ?? "");
  if (/[,"\n]/.test(t)) return `"${t.replace(/"/g,'""')}"`;
  return t;
}
function exportPro(){
  const { table } = computeStandings();
  const rn = currentRoundNumber();
  const top3 = table.slice(0,3);

  const lines = [];
  lines.push("DOMINO SUIZO PRO 2v2 OFFLINE");
  lines.push(`RONDAS_JUGADAS,${rn}`);
  lines.push("");

  lines.push("TOP_3");
  lines.push("pos,player,PTS,PF,DIF,PJ,bench");
  top3.forEach((s,i)=>lines.push([i+1,q(s.player),s.PTS,s.PF,s.DIF,s.PJ,s.bench].join(",")));
  lines.push("");

  lines.push("MATCHES");
  lines.push(["round","table","A1","A2","B1","B2","ptsA","ptsB"].join(","));
  for(const m of state.rounds){
    lines.push([m.round,m.table,q(m.A1),q(m.A2),q(m.B1),q(m.B2),m.ptsA??"",m.ptsB??""].join(","));
  }
  lines.push("");

  lines.push("STANDINGS");
  lines.push(["rank","player","PJ","G","P","PF","PC","DIF","PTS","bench"].join(","));
  table.forEach((s,i)=>{
    lines.push([i+1,q(s.player),s.PJ,s.G,s.P,s.PF,s.PC,s.DIF,s.PTS,s.bench].join(","));
  });

  const blob = new Blob([lines.join("\n")], {type:"text/csv;charset=utf-8;"});
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href=url;
  a.download=`domino-suizo-pro-2v2-offline-r${rn}.csv`;
  document.body.appendChild(a); a.click(); a.remove();
  URL.revokeObjectURL(url);
}

/* =================== UI =================== */
const els = {
  playersInput: document.getElementById("playersInput"),
  playersCount: document.getElementById("playersCount"),
  matches: document.getElementById("matches"),
  tableBody: document.getElementById("tableBody"),
  roundPill: document.getElementById("roundPill"),
  arbPill: document.getElementById("arbPill"),

  btnLoadPlayers: document.getElementById("btnLoadPlayers"),
  btnGenR1: document.getElementById("btnGenR1"),
  btnGenNext: document.getElementById("btnGenNext"),
  btnSaveScores: document.getElementById("btnSaveScores"),
  btnReset: document.getElementById("btnReset"),
  btnExport: document.getElementById("btnExport"),

  statusBox: document.getElementById("statusBox"),
  diagBox: document.getElementById("diagBox"),

  btnMesaMode: document.getElementById("btnMesaMode"),
  mesaWrap: document.getElementById("mesaWrap"),
  mesaTitle: document.getElementById("mesaTitle"),
  mesaTeams: document.getElementById("mesaTeams"),
  mesaIdxPill: document.getElementById("mesaIdxPill"),
  mesaPtsA: document.getElementById("mesaPtsA"),
  mesaPtsB: document.getElementById("mesaPtsB"),
  mesaPrev: document.getElementById("mesaPrev"),
  mesaNext: document.getElementById("mesaNext"),
  mesaSaveOne: document.getElementById("mesaSaveOne"),
  mesaExit: document.getElementById("mesaExit"),

  btnArbToggle: document.getElementById("btnArbToggle"),
  btnArbSetPin: document.getElementById("btnArbSetPin"),

  modalBack: document.getElementById("modalBack"),
  modalTitle: document.getElementById("modalTitle"),
  modalContent: document.getElementById("modalContent"),
  modalClose: document.getElementById("modalClose"),
  modalCloseTop: document.getElementById("modalCloseTop"),
};

function showStatus(html, warn=false){
  els.statusBox.style.display = "block";
  els.statusBox.className = "notice" + (warn ? " warn" : "");
  els.statusBox.innerHTML = html;
}
function hideStatus(){ els.statusBox.style.display = "none"; }

function renderPlayersBox(){
  els.playersInput.value = state.players.join("\n");
  els.playersCount.textContent = state.players.length ? `${state.players.length} jugador(es) cargados` : "Sin jugadores cargados";
}

function labelWrap(text, inputEl){
  const lab = document.createElement("label");
  lab.innerHTML = `<span>${escapeHtml(text)}</span>`;
  lab.appendChild(inputEl);
  return lab;
}

function renderMesaMode(){
  const rn = currentRoundNumber();
  if(rn === 0){
    els.mesaTitle.textContent = "Modo Mesa";
    els.mesaTeams.textContent = "Genera una ronda primero.";
    els.mesaIdxPill.textContent = "‚Äî";
    els.mesaPtsA.value = "";
    els.mesaPtsB.value = "";
    return;
  }
  const ms = matchesInRound(rn);
  if(!ms.length){
    els.mesaTitle.textContent = "Modo Mesa";
    els.mesaTeams.textContent = "No hay mesas.";
    els.mesaIdxPill.textContent = "‚Äî";
    return;
  }
  state.mesaIdx = clamp(state.mesaIdx, 0, ms.length-1);
  const m = ms[state.mesaIdx];

  els.mesaTitle.textContent = `Mesa ${m.table}`;
  els.mesaTeams.textContent = `A: ${m.A1} + ${m.A2}   vs   B: ${m.B1} + ${m.B2}`;
  els.mesaIdxPill.textContent = `Mesa ${state.mesaIdx+1}/${ms.length}`;

  els.mesaPtsA.value = m.ptsA ?? "";
  els.mesaPtsB.value = m.ptsB ?? "";
  els.mesaPrev.disabled = state.mesaIdx === 0;
  els.mesaNext.disabled = state.mesaIdx === ms.length-1;
}

function renderRound(){
  const rn = currentRoundNumber();
  els.roundPill.textContent = `Ronda: ${rn}/${MAX_ROUNDS}`;
  els.arbPill.textContent = `√Årbitro: ${state.arbOn ? "ON" : "OFF"}`;

  els.mesaWrap.style.display = state.mesaMode ? "block" : "none";
  els.matches.style.display = state.mesaMode ? "none" : "block";

  if(rn === 0){
    els.matches.innerHTML = `<div class="muted">A√∫n no hay rondas. Presiona <b>Generar Ronda 1</b>.</div>`;
    if(state.mesaMode) renderMesaMode();
    return;
  }

  const ms = matchesInRound(rn);
  const bench = state._lastBench && state._lastBench.round===rn ? state._lastBench.players : [];

  if(state.mesaMode){
    renderMesaMode();
    return;
  }

  els.matches.innerHTML = "";
  if(bench && bench.length){
    const d = document.createElement("div");
    d.className = "muted";
    d.style.marginBottom = "8px";
    d.innerHTML = `<span class="pill">Banco</span> ${bench.map(escapeHtml).join(", ")} (no juegan esta ronda)`;
    els.matches.appendChild(d);
  }

  for(const m of ms){
    const div = document.createElement("div");
    div.className = "match";

    const names = document.createElement("div");
    names.className = "names";
    names.innerHTML = `
      <div class="muted">Mesa ${m.table}</div>
      <div class="line"><span class="pill">A</span> <b>${escapeHtml(m.A1)}</b> + <b>${escapeHtml(m.A2)}</b>
        <span class="vs">vs</span>
        <span class="pill">B</span> <b>${escapeHtml(m.B1)}</b> + <b>${escapeHtml(m.B2)}</b></div>
    `;

    const scores = document.createElement("div");
    scores.className = "scores";

    const inpA = document.createElement("input");
    inpA.type="number"; inpA.min="0"; inpA.step="1"; inpA.style.width="90px";
    inpA.value = m.ptsA ?? "";

    const inpB = document.createElement("input");
    inpB.type="number"; inpB.min="0"; inpB.step="1"; inpB.style.width="90px";
    inpB.value = m.ptsB ?? "";

    const allowEdit = (state.arbOn || m.round === rn);
    inpA.disabled = !allowEdit;
    inpB.disabled = !allowEdit;

    scores.appendChild(labelWrap("Puntos A", inpA));
    scores.appendChild(labelWrap("Puntos B", inpB));

    const winner = document.createElement("div");
    winner.className = "winner";

    function calcResult(){
      const a = Number(m.ptsA), b = Number(m.ptsB);
      if(!Number.isFinite(a) || !Number.isFinite(b)) return "";
      if(a===b) return "‚ö†Ô∏è Empate NO permitido";
      return (a>b) ? "Gana A" : "Gana B";
    }
    function renderResult(){
      const r = calcResult();
      if(!r) return `<span class="muted">‚Äî</span>`;
      const bad = r.includes("NO permitido");
      return `<span class="pill"${bad?` style="border-color:#d12b2b;color:#ffd0d0"`:""}>Resultado: ${escapeHtml(r)}</span>`;
    }
    winner.innerHTML = renderResult();

    inpA.addEventListener("input", ()=>{ m.ptsA = inpA.value; winner.innerHTML = renderResult(); });
    inpB.addEventListener("input", ()=>{ m.ptsB = inpB.value; winner.innerHTML = renderResult(); });

    div.appendChild(names);
    div.appendChild(scores);
    div.appendChild(winner);
    els.matches.appendChild(div);
  }
}

function renderTable(){
  const { table } = computeStandings();
  els.tableBody.innerHTML = "";
  let i=1;
  for(const s of table){
    const tr = document.createElement("tr");
    tr.innerHTML = `
      <td>${i++}</td>
      <td><button class="secondary" style="padding:6px 10px; border-radius:10px;" data-audit="${escapeHtml(s.player)}">${escapeHtml(s.player)}</button></td>
      <td>${s.PJ}</td>
      <td>${s.G}</td>
      <td>${s.P}</td>
      <td>${s.PF}</td>
      <td>${s.PC}</td>
      <td>${s.DIF}</td>
      <td><b>${s.PTS}</b></td>
      <td>${s.bench}</td>
    `;
    els.tableBody.appendChild(tr);
  }
  els.tableBody.querySelectorAll("button[data-audit]").forEach(btn=>{
    btn.addEventListener("click", ()=>openAudit(btn.getAttribute("data-audit")));
  });
}

function renderStatus(){
  hideStatus();
  const n = state.players.length;
  if(!n) return;
  if(n < 4){ showStatus("Necesitas m√≠nimo 4 jugadores.", true); return; }
  if(n % 4 !== 0){
    const need = n % 4;
    showStatus(`No es m√∫ltiplo de 4. Cada ronda descansan <b>${need}</b> jugador(es) (banco rotativo).`, false);
  }
}

function renderAll(){
  renderPlayersBox();
  renderRound();
  renderTable();
  renderStatus();
  els.diagBox.innerHTML = buildDiagnostics();

  els.btnGenR1.disabled = !(state.players.length>=4) || currentRoundNumber()>0;
  els.btnGenNext.disabled = !(state.players.length>=4) || !canGenerateNextRound() || currentRoundNumber()>=MAX_ROUNDS;
  els.btnMesaMode.textContent = state.mesaMode ? "Modo Lista" : "Modo Mesa";
}

function validateRoundComplete(rn){
  const ms = matchesInRound(rn);
  for(const m of ms){
    const a = Number(m.ptsA), b = Number(m.ptsB);
    if(!Number.isFinite(a) || !Number.isFinite(b)) return {ok:false, msg:"Faltan puntos en alguna mesa."};
    if(a === b) return {ok:false, msg:"No se permiten empates. Ajusta los puntos."};
  }
  return {ok:true, msg:"OK"};
}

/* =================== Eventos =================== */
els.btnLoadPlayers.addEventListener("click", ()=>{
  const list = uniqNonEmptyLines(els.playersInput.value);
  if(list.length < 4) return alert("Necesitas m√≠nimo 4 jugadores.");
  if(currentRoundNumber()>0 && !state.arbOn){
    alert("Para cambiar jugadores con rondas ya creadas, activa √°rbitro (PIN).");
    return;
  }
  if(currentRoundNumber()>0 && state.arbOn){
    const ok = confirm("Cambiar jugadores con torneo en progreso puede romper consistencia. ¬øContinuar?");
    if(!ok) return;
  }
  state.players = list;
  saveState();
  renderAll();
});

els.btnGenR1.addEventListener("click", generateRound1);
els.btnGenNext.addEventListener("click", generateNextRound);

els.btnSaveScores.addEventListener("click", ()=>{
  const rn = currentRoundNumber();
  if(rn > 0){
    const res = validateRoundComplete(rn);
    if(!res.ok) return alert(res.msg);
  }
  saveState();
  renderAll();
  alert("Puntos guardados ‚úÖ");
});

els.btnReset.addEventListener("click", resetAll);
els.btnExport.addEventListener("click", exportPro);

els.btnMesaMode.addEventListener("click", ()=>{
  state.mesaMode = !state.mesaMode;
  saveState();
  renderAll();
});

els.mesaPrev.addEventListener("click", ()=>{
  state.mesaIdx = Math.max(0, state.mesaIdx-1);
  saveState();
  renderAll();
});
els.mesaNext.addEventListener("click", ()=>{
  const rn = currentRoundNumber();
  const ms = matchesInRound(rn);
  state.mesaIdx = Math.min(ms.length-1, state.mesaIdx+1);
  saveState();
  renderAll();
});
els.mesaSaveOne.addEventListener("click", ()=>{
  const rn = currentRoundNumber();
  const ms = matchesInRound(rn);
  if(!ms.length) return;
  const m = ms[state.mesaIdx];

  m.ptsA = els.mesaPtsA.value;
  m.ptsB = els.mesaPtsB.value;

  const a = Number(m.ptsA), b = Number(m.ptsB);
  if(!Number.isFinite(a) || !Number.isFinite(b)) return alert("Pon puntos en ambos equipos.");
  if(a===b) return alert("No se permiten empates.");

  saveState();
  renderAll();
  alert(`Mesa ${m.table} guardada ‚úÖ`);
});

els.mesaPtsA.addEventListener("input", ()=>{
  const rn = currentRoundNumber();
  const ms = matchesInRound(rn);
  if(!ms.length) return;
  ms[state.mesaIdx].ptsA = els.mesaPtsA.value;
});
els.mesaPtsB.addEventListener("input", ()=>{
  const rn = currentRoundNumber();
  const ms = matchesInRound(rn);
  if(!ms.length) return;
  ms[state.mesaIdx].ptsB = els.mesaPtsB.value;
});

els.mesaExit.addEventListener("click", ()=>{
  state.mesaMode = false;
  saveState();
  renderAll();
});

els.btnArbToggle.addEventListener("click", toggleArb);
els.btnArbSetPin.addEventListener("click", setArbPin);

els.modalClose.addEventListener("click", closeModal);
els.modalCloseTop.addEventListener("click", closeModal);
els.modalBack.addEventListener("click", (e)=>{ if(e.target === els.modalBack) closeModal(); });

/* =================== Init =================== */
loadState();
renderAll();
</script>
</body>
</html>
