<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Domin√≥ Suizo PRO ‚Äì 2vs2 Offline</title>
  <style>
    :root { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial; }
    body { margin:0; background:#0b1220; color:#e8eefc; }
    header { padding:16px 18px; background:#121a2b; position:sticky; top:0; border-bottom:1px solid #22304f; z-index:10; }
    header h1 { margin:0; font-size:18px; }
    main { padding:16px 18px; max-width:1200px; margin:0 auto; }
    .grid { display:grid; gap:12px; grid-template-columns:1fr; }
    @media (min-width: 900px){ .grid { grid-template-columns: 1.1fr 1fr; } }
    .card { background:#121a2b; border:1px solid #22304f; border-radius:14px; padding:14px; }
    .card h2 { margin:0 0 10px; font-size:15px; }
    textarea { width:100%; min-height:160px; background:#0b1220; color:#e8eefc; border:1px solid #22304f; border-radius:10px; padding:10px; resize:vertical; }
    input, select { background:#0b1220; color:#e8eefc; border:1px solid #22304f; border-radius:10px; padding:8px 10px; }
    .row { display:flex; gap:10px; flex-wrap:wrap; align-items:center; }
    button { background:#2b65ff; color:white; border:0; border-radius:10px; padding:10px 12px; cursor:pointer; font-weight:650; }
    button.secondary { background:#1b2847; border:1px solid #22304f; }
    button.danger { background:#d12b2b; }
    button:disabled { opacity:.55; cursor:not-allowed; }
    .muted { color:#9fb1db; font-size:12px; }
    .pill { display:inline-block; padding:3px 8px; border:1px solid #22304f; border-radius:999px; font-size:12px; color:#cfe0ff; }
    .flex-between { display:flex; justify-content:space-between; gap:12px; align-items:center; }
    .notice { padding:10px; border:1px solid #22304f; border-radius:12px; background:#0b1220; }
    .notice.warn { border-color:#d12b2b; color:#ffd0d0; }
    .matches { display:flex; flex-direction:column; gap:10px; }
    .match { border:1px solid #22304f; border-radius:12px; padding:10px; background:#0f1830; display:grid; grid-template-columns:1fr; gap:10px; }
    @media (min-width: 750px){ .match { grid-template-columns: 1.7fr 1fr .9fr; } }
    .names { display:flex; flex-direction:column; gap:6px; }
    .line { display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
    .line b { font-size:14px; }
    .vs { color:#9fb1db; font-size:12px; margin:4px 0; }
    .scores { display:flex; gap:10px; align-items:center; flex-wrap:wrap; }
    .scores label { display:flex; gap:6px; align-items:center; font-size:12px; color:#cfe0ff; }
    .winner { display:flex; align-items:center; justify-content:flex-end; }
    table { width:100%; border-collapse:collapse; overflow:hidden; border-radius:12px; }
    th, td { border-bottom:1px solid #22304f; padding:10px; text-align:left; font-size:13px; }
    th { background:#0f1830; } /* no sticky en m√≥vil */
    .small { font-size:12px; }
    .kbd { font-family: ui-monospace, SFMono-Regular, Menlo, monospace; font-size:12px; padding:2px 6px; border:1px solid #22304f; border-radius:8px; background:#0b1220; color:#cfe0ff; }
  </style>
</head>

<body>
<header class="flex-between">
  <h1>üÅ´ Domin√≥ Suizo PRO ‚Äì 2vs2 (Offline)</h1>
  <div class="row">
    <span class="pill" id="roundPill">Ronda: 0/5</span>
    <button class="secondary" id="btnExport">Exportar CSV</button>
    <button class="danger" id="btnReset">Reset</button>
  </div>
</header>

<main class="grid">
  <section class="card">
    <h2>Jugadores</h2>
    <p class="muted">
      Pega <b>un jugador por l√≠nea</b>. Luego: <b>Guardar jugadores</b> ‚Üí <b>Generar Ronda 1</b>.<br/>
      Ranking: <b>Ganadas</b> ‚Üí <b>PF (puntos a favor)</b> ‚Üí <b>DIF</b>. <b>No empates</b>. <b>5 rondas</b>.
    </p>

    <textarea id="playersInput" placeholder="Ej:
Juan
Pedro
Luis
Ana
Carlos
Miguel
..."></textarea>

    <div class="row" style="margin-top:10px;">
      <button id="btnLoadPlayers">Guardar jugadores</button>
      <button class="secondary" id="btnGenR1">Generar Ronda 1</button>
      <button class="secondary" id="btnGenNext">Siguiente Ronda (Suizo PRO)</button>
      <span class="muted small" id="playersCount"></span>
    </div>

    <div class="notice" style="margin-top:12px;">
      <div class="row">
        <span class="pill">Modo impar</span>
        <span class="muted small">Si NO es m√∫ltiplo de 4: descansan 1‚Äì3 jugadores por ronda (banco rotativo justo).</span>
      </div>
      <div class="row" style="margin-top:8px;">
        <span class="pill">Consejo</span>
        <span class="muted small">
          Para 30 jugadores, cada ronda juegan 28 y descansan 2. En 5 rondas es normal que algunos jueguen 4 y otros 5 (se reparte lo m√°s parejo).
        </span>
      </div>
      <div class="row" style="margin-top:8px;">
        <span class="pill">Atajo</span>
        <span class="muted small">Si ves versi√≥n vieja en iPhone: abre con <span class="kbd">?v=999</span>.</span>
      </div>
    </div>

    <div id="statusBox" class="notice" style="margin-top:12px; display:none;"></div>
  </section>

  <section class="card">
    <div class="flex-between">
      <h2>Ronda actual</h2>
      <button id="btnSaveScores">Guardar puntos</button>
    </div>
    <div class="matches" id="matches"></div>
    <p class="muted small">Puntos por equipo. El ganador sale por puntos. <b>No empates</b>.</p>
  </section>

  <section class="card" style="grid-column:1/-1;">
    <div class="flex-between">
      <h2>Tabla (se mueve sola)</h2>
      <span class="muted small">Orden: Ganadas ‚Üí PF ‚Üí DIF</span>
    </div>
    <div style="overflow:auto; border-radius:12px; border:1px solid #22304f;">
      <table>
        <thead>
          <tr>
            <th>#</th><th>Jugador</th><th>PJ</th><th>G</th><th>P</th><th>PF</th><th>PC</th><th>DIF</th><th>Ganadas</th><th>Descansos</th>
          </tr>
        </thead>
        <tbody id="tableBody"></tbody>
      </table>
    </div>
  </section>

  <section class="card" style="grid-column:1/-1;">
    <div class="flex-between">
      <h2>Diagn√≥stico (PRO)</h2>
      <span class="muted small">repeticiones y por qu√©</span>
    </div>
    <div id="diagBox" class="notice"></div>
  </section>
</main>

<script>
/* =================== Config =================== */
const MAX_ROUNDS = 5;

/* Penalidades para emparejar (m√°s alto = evita m√°s) */
const PENAL_TEAM_REPEAT = 200;  // repetir pareja (muy fuerte)
const PENAL_VS_REPEAT   = 40;   // repetir rivales (fuerte)
const PENAL_SWAP        = 3;    // mover alguien entre mesas (bajo, solo si ayuda)
const PENAL_BENCH_EXTRA = 5;    // que alguien descanse m√°s que el m√≠nimo (evitar)

/* =================== Storage =================== */
const STORAGE_KEY = "domino_suizo_2v2_offline_pro_v3";

/* =================== Estado =================== */
const state = {
  players: [], // [name]
  rounds: [],  // {round, table, A1,A2,B1,B2, ptsA, ptsB}
  benchHistory: {}, // {name: count}
  _lastBench: null  // {round, players:[...]}
};

function saveState(){ localStorage.setItem(STORAGE_KEY, JSON.stringify(state)); }
function loadState(){
  const raw = localStorage.getItem(STORAGE_KEY);
  if(!raw) return;
  try{
    const s = JSON.parse(raw);
    if(s && Array.isArray(s.players) && Array.isArray(s.rounds)){
      state.players = s.players;
      state.rounds = s.rounds;
      state.benchHistory = s.benchHistory || {};
      state._lastBench = s._lastBench || null;
    }
  }catch{}
}
function resetAll(){
  if(!confirm("¬øSeguro que quieres borrar todo el torneo?")) return;
  state.players = [];
  state.rounds = [];
  state.benchHistory = {};
  state._lastBench = null;
  saveState();
  renderAll();
}

/* =================== Util =================== */
function escapeHtml(s){
  return String(s).replace(/[&<>"']/g, m => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#039;'}[m]));
}
function uniqNonEmptyLines(text){
  const lines = text.split(/\r?\n/).map(s=>s.trim()).filter(Boolean);
  const seen = new Set();
  const out = [];
  for(const n of lines){
    const k = n.toLowerCase();
    if(!seen.has(k)){ seen.add(k); out.push(n); }
  }
  return out;
}
function shuffle(arr){
  const a = arr.slice();
  for(let i=a.length-1;i>0;i--){
    const j = Math.floor(Math.random()*(i+1));
    [a[i],a[j]]=[a[j],a[i]];
  }
  return a;
}
function currentRoundNumber(){
  return state.rounds.reduce((m,x)=>Math.max(m,x.round),0);
}
function matchesInRound(rn){
  return state.rounds.filter(m=>m.round===rn).sort((a,b)=>a.table-b.table);
}
function pairKey(a,b){ a=String(a); b=String(b); return (a<b)?`${a}|${b}`:`${b}|${a}`; }
function teamKey(a1,a2){ return pairKey(a1,a2); }
function teamsVsKey(tA, tB){ return (tA<tB)?`${tA}||${tB}`:`${tB}||${tA}`; }

/* =================== Standings ===================
   Ranking: Ganadas -> PF -> DIF
*/
function computeStandings(){
  const stats = new Map();
  for(const p of state.players){
    stats.set(p,{player:p,PJ:0,G:0,P:0,PF:0,PC:0,DIF:0,PTS:0,bench:(state.benchHistory[p]||0)});
  }

  const teammateUsed = new Set();
  const teamVsUsed = new Set();

  for(const m of state.rounds){
    if(!stats.has(m.A1)||!stats.has(m.A2)||!stats.has(m.B1)||!stats.has(m.B2)) continue;

    const tA = teamKey(m.A1,m.A2);
    const tB = teamKey(m.B1,m.B2);
    teammateUsed.add(tA); teammateUsed.add(tB);
    teamVsUsed.add(teamsVsKey(tA,tB));

    [m.A1,m.A2,m.B1,m.B2].forEach(p=>stats.get(p).PJ++);

    const a = Number(m.ptsA);
    const b = Number(m.ptsB);
    if(!Number.isFinite(a) || !Number.isFinite(b)) continue;
    if(a===b) continue;

    if(a>b){
      [m.A1,m.A2].forEach(p=>{ stats.get(p).G++; stats.get(p).PTS++; });
      [m.B1,m.B2].forEach(p=>{ stats.get(p).P++; });
    } else {
      [m.B1,m.B2].forEach(p=>{ stats.get(p).G++; stats.get(p).PTS++; });
      [m.A1,m.A2].forEach(p=>{ stats.get(p).P++; });
    }

    [m.A1,m.A2].forEach(p=>{ stats.get(p).PF += a; stats.get(p).PC += b; });
    [m.B1,m.B2].forEach(p=>{ stats.get(p).PF += b; stats.get(p).PC += a; });
  }

  for(const s of stats.values()) s.DIF = s.PF - s.PC;

  const table = Array.from(stats.values()).sort((x,y)=>{
    if(y.PTS !== x.PTS) return y.PTS - x.PTS;
    if(y.PF  !== x.PF ) return y.PF  - x.PF;
    if(y.DIF !== x.DIF) return y.DIF - x.DIF;
    return x.player.localeCompare(y.player);
  });

  const ranked = table.map(x=>x.player);

  return { table, ranked, teammateUsed, teamVsUsed };
}

/* =================== Validaci√≥n =================== */
function canGenerateNextRound(){
  if(state.players.length < 4) return false;
  const rn = currentRoundNumber();
  if(rn===0) return true;

  const ms = matchesInRound(rn);
  for(const m of ms){
    const a = Number(m.ptsA), b = Number(m.ptsB);
    if(!Number.isFinite(a) || !Number.isFinite(b)) return false;
    if(a===b) return false;
  }
  return true;
}

/* =================== Banco rotativo justo =================== */
function pickBench(poolNames, need){
  // escoger con menos descansos; desempatar aleatorio
  const counts = state.benchHistory || {};
  const scored = poolNames.map(n=>({n, c:(counts[n]||0)})).sort((a,b)=>a.c-b.c);
  const bench = [];
  let i=0;
  while(bench.length < need && i < scored.length){
    const minC = scored[i].c;
    const same = [];
    while(i < scored.length && scored[i].c === minC){
      same.push(scored[i].n); i++;
    }
    for(const n of shuffle(same)){
      if(bench.length < need) bench.push(n);
    }
  }
  return bench;
}
function markBench(bench){
  for(const n of bench) state.benchHistory[n] = (state.benchHistory[n]||0) + 1;
}

/* =================== Suizo PRO por mesas (con swaps m√≠nimos) ===================
   1) Orden ranked
   2) Si no m√∫ltiplo de 4 => banco (need = n%4)
   3) Grupos de 4 por mesa: top4 mesa1, next4 mesa2...
   4) En cada mesa, escoger split de equipos minimizando repeticiones
   5) Si mesa tiene penalidad >0, intentar swap m√≠nimo con mesa siguiente (1 jugador) para bajar suma
*/
function generateRound1(){
  if(state.players.length < 4) return alert("Necesitas m√≠nimo 4 jugadores.");
  if(currentRoundNumber() > 0) return alert("Ya hay rondas. Usa 'Siguiente Ronda'.");
  const ranked = shuffle(state.players);
  addNewRoundFromRanked(ranked, true);
}
function generateNextRound(){
  if(currentRoundNumber() >= MAX_ROUNDS) return alert("Ya se jugaron 5 rondas ‚úÖ");
  if(!canGenerateNextRound()) return alert("Completa puntos de la ronda actual (sin empates).");

  const { ranked, teammateUsed, teamVsUsed } = computeStandings();
  addNewRoundFromRanked(ranked, false, teammateUsed, teamVsUsed);
}

function bestSplitOf4(group, usedTeammate, usedVs){
  const [a,b,c,d] = group;

  const options = [
    {A:[a,b], B:[c,d]},
    {A:[a,c], B:[b,d]},
    {A:[a,d], B:[b,c]},
  ];

  let best = null;

  for(const opt of options){
    const tA = teamKey(opt.A[0], opt.A[1]);
    const tB = teamKey(opt.B[0], opt.B[1]);
    const vK = teamsVsKey(tA, tB);

    const repTeam = (usedTeammate.has(tA)?1:0) + (usedTeammate.has(tB)?1:0);
    const repVs = usedVs.has(vK)?1:0;

    const score = repTeam * PENAL_TEAM_REPEAT + repVs * PENAL_VS_REPEAT;

    if(!best || score < best.score){
      best = { ...opt, tA, tB, vK, score, repTeam, repVs };
    }
  }
  return best;
}

function addNewRoundFromRanked(ranked, isRound1, teammateUsed, teamVsUsed){
  let pool = ranked.slice();

  // Banco si sobran 1..3 para m√∫ltiplo de 4
  let bench = [];
  if(pool.length % 4 !== 0){
    const need = pool.length % 4; // 1..3
    bench = pickBench(pool, need);
    const benchSet = new Set(bench);
    pool = pool.filter(n=>!benchSet.has(n));
    markBench(bench);
  }

  const usedTeammate = new Set(teammateUsed || []);
  const usedVs = new Set(teamVsUsed || []);

  // mesas por bloques de 4
  let tables = [];
  for(let i=0;i<pool.length;i+=4){
    tables.push(pool.slice(i,i+4));
  }

  // swaps m√≠nimos entre mesas para bajar penalidad total
  for(let i=0;i<tables.length-1;i++){
    const g1 = tables[i], g2 = tables[i+1];

    const s1 = bestSplitOf4(g1, usedTeammate, usedVs);
    const s2 = bestSplitOf4(g2, usedTeammate, usedVs);

    // Si ya perfecto, no tocar
    if(s1.score===0 && s2.score===0) continue;

    let bestTotal = s1.score + s2.score;
    let bestSwap = null;

    for(let x=0;x<4;x++){
      for(let y=0;y<4;y++){
        const ng1 = g1.slice(), ng2 = g2.slice();
        [ng1[x], ng2[y]] = [ng2[y], ng1[x]];

        const ns1 = bestSplitOf4(ng1, usedTeammate, usedVs);
        const ns2 = bestSplitOf4(ng2, usedTeammate, usedVs);
        const total = ns1.score + ns2.score + PENAL_SWAP;

        if(total < bestTotal){
          bestTotal = total;
          bestSwap = { ng1, ng2 };
        }
      }
    }

    if(bestSwap){
      tables[i] = bestSwap.ng1;
      tables[i+1] = bestSwap.ng2;
    }
  }

  // Construir matches (actualizando historial local dentro de la misma ronda)
  const rn = currentRoundNumber() + 1;
  let tableNo = 1;

  const roundDiag = { repTeam:0, repVs:0, swaps:0 };
  for(const group of tables){
    const pick = bestSplitOf4(group, usedTeammate, usedVs);
    if(pick.repTeam) roundDiag.repTeam += pick.repTeam;
    if(pick.repVs) roundDiag.repVs += pick.repVs;

    usedTeammate.add(pick.tA); usedTeammate.add(pick.tB);
    usedVs.add(pick.vK);

    state.rounds.push({
      round: rn, table: tableNo++,
      A1: pick.A[0], A2: pick.A[1],
      B1: pick.B[0], B2: pick.B[1],
      ptsA:"", ptsB:""
    });
  }

  state._lastBench = bench.length ? { round: rn, players: bench.slice() } : null;

  saveState();
  renderAll();
}

/* =================== Diagn√≥stico =================== */
function buildDiagnostics(){
  const { teammateUsed, teamVsUsed } = computeStandings();

  // contar repeticiones de parejas/rivales
  const teamCount = new Map();
  const vsCount = new Map();

  for(const m of state.rounds){
    const tA = teamKey(m.A1,m.A2);
    const tB = teamKey(m.B1,m.B2);
    const vK = teamsVsKey(tA,tB);

    teamCount.set(tA, (teamCount.get(tA)||0)+1);
    teamCount.set(tB, (teamCount.get(tB)||0)+1);
    vsCount.set(vK, (vsCount.get(vK)||0)+1);
  }

  const repTeams = Array.from(teamCount.entries()).filter(([,c])=>c>1).sort((a,b)=>b[1]-a[1]);
  const repVs = Array.from(vsCount.entries()).filter(([,c])=>c>1).sort((a,b)=>b[1]-a[1]);

  const topTeams = repTeams.slice(0,8).map(([k,c])=>`<li><b>${escapeHtml(k.replace("|"," + "))}</b> ‚Üí ${c} veces</li>`).join("");
  const topVs = repVs.slice(0,8).map(([k,c])=>{
    const parts = k.split("||");
    return `<li><b>${escapeHtml(parts[0].replace("|"," + "))}</b> vs <b>${escapeHtml(parts[1].replace("|"," + "))}</b> ‚Üí ${c} veces</li>`;
  }).join("");

  const benchSorted = state.players
    .map(p=>({p, c:(state.benchHistory[p]||0)}))
    .sort((a,b)=>b.c-a.c);

  const benchTop = benchSorted.slice(0,10).map(x=>`${escapeHtml(x.p)} (${x.c})`).join(", ");

  const rn = currentRoundNumber();
  const benchThis = state._lastBench && state._lastBench.round===rn ? state._lastBench.players : [];

  return `
    <div class="row" style="margin-bottom:8px;">
      <span class="pill">Repeticiones</span>
      <span class="muted small">Con 5 rondas a veces es inevitable. El sistema minimiza.</span>
    </div>

    <div class="row" style="gap:18px; align-items:flex-start;">
      <div style="flex:1; min-width:260px;">
        <div class="muted"><b>Parejas repetidas</b> (top)</div>
        <ul class="muted small">${topTeams || "<li>Ninguna repetida ‚úÖ</li>"}</ul>
      </div>
      <div style="flex:1; min-width:260px;">
        <div class="muted"><b>Rivales repetidos</b> (top)</div>
        <ul class="muted small">${topVs || "<li>Ning√∫n cruce repetido ‚úÖ</li>"}</ul>
      </div>
    </div>

    <div class="row" style="margin-top:10px;">
      <span class="pill">Banco</span>
      <span class="muted small">M√°s descansos: ${benchTop || "‚Äî"}</span>
    </div>
    <div class="row" style="margin-top:6px;">
      <span class="pill">Esta ronda</span>
      <span class="muted small">${benchThis.length ? ("Descansan: " + benchThis.map(escapeHtml).join(", ")) : "Sin banco"}</span>
    </div>
  `;
}

/* =================== UI =================== */
const els = {
  playersInput: document.getElementById("playersInput"),
  playersCount: document.getElementById("playersCount"),
  matches: document.getElementById("matches"),
  tableBody: document.getElementById("tableBody"),
  roundPill: document.getElementById("roundPill"),
  btnLoadPlayers: document.getElementById("btnLoadPlayers"),
  btnGenR1: document.getElementById("btnGenR1"),
  btnGenNext: document.getElementById("btnGenNext"),
  btnSaveScores: document.getElementById("btnSaveScores"),
  btnReset: document.getElementById("btnReset"),
  btnExport: document.getElementById("btnExport"),
  statusBox: document.getElementById("statusBox"),
  diagBox: document.getElementById("diagBox"),
};

function showStatus(html, warn=false){
  els.statusBox.style.display = "block";
  els.statusBox.className = "notice" + (warn ? " warn" : "");
  els.statusBox.innerHTML = html;
}
function hideStatus(){ els.statusBox.style.display = "none"; }

function renderPlayersBox(){
  els.playersInput.value = state.players.join("\n");
  els.playersCount.textContent = state.players.length ? `${state.players.length} jugador(es) cargados` : "Sin jugadores cargados";
}

function renderRound(){
  const rn = currentRoundNumber();
  els.roundPill.textContent = `Ronda: ${rn}/${MAX_ROUNDS}`;
  els.matches.innerHTML = "";

  if(rn === 0){
    els.matches.innerHTML = `<div class="muted">A√∫n no hay rondas. Presiona <b>Generar Ronda 1</b>.</div>`;
    return;
  }

  const ms = matchesInRound(rn);
  const bench = state._lastBench && state._lastBench.round===rn ? state._lastBench.players : [];

  if(bench && bench.length){
    const d = document.createElement("div");
    d.className = "muted";
    d.style.marginBottom = "8px";
    d.innerHTML = `<span class="pill">Banco</span> ${bench.map(escapeHtml).join(", ")} (no juegan esta ronda)`;
    els.matches.appendChild(d);
  }

  for(const m of ms){
    const div = document.createElement("div");
    div.className = "match";

    const names = document.createElement("div");
    names.className = "names";
    names.innerHTML = `
      <div class="muted">Mesa ${m.table}</div>
      <div class="line"><span class="pill">A</span> <b>${escapeHtml(m.A1)}</b> + <b>${escapeHtml(m.A2)}</b>
        <span class="vs">vs</span>
        <span class="pill">B</span> <b>${escapeHtml(m.B1)}</b> + <b>${escapeHtml(m.B2)}</b></div>
    `;

    const scores = document.createElement("div");
    scores.className = "scores";

    const inpA = document.createElement("input");
    inpA.type="number"; inpA.min="0"; inpA.step="1"; inpA.style.width="90px";
    inpA.value = m.ptsA ?? "";

    const inpB = document.createElement("input");
    inpB.type="number"; inpB.min="0"; inpB.step="1"; inpB.style.width="90px";
    inpB.value = m.ptsB ?? "";

    scores.appendChild(labelWrap("Puntos A", inpA));
    scores.appendChild(labelWrap("Puntos B", inpB));

    const winner = document.createElement("div");
    winner.className = "winner";

    function calcResult(){
      const a = Number(m.ptsA), b = Number(m.ptsB);
      if(!Number.isFinite(a) || !Number.isFinite(b)) return "";
      if(a===b) return "‚ö†Ô∏è Empate NO permitido";
      return (a>b) ? "Gana A" : "Gana B";
    }
    function renderResult(){
      const r = calcResult();
      if(!r) return `<span class="muted">‚Äî</span>`;
      const bad = r.includes("NO permitido");
      return `<span class="pill"${bad?` style="border-color:#d12b2b;color:#ffd0d0"`:""}>Resultado: ${escapeHtml(r)}</span>`;
    }
    winner.innerHTML = renderResult();

    inpA.addEventListener("input", ()=>{ m.ptsA = inpA.value; winner.innerHTML = renderResult(); });
    inpB.addEventListener("input", ()=>{ m.ptsB = inpB.value; winner.innerHTML = renderResult(); });

    div.appendChild(names);
    div.appendChild(scores);
    div.appendChild(winner);
    els.matches.appendChild(div);
  }
}

function labelWrap(text, inputEl){
  const lab = document.createElement("label");
  lab.innerHTML = `<span>${escapeHtml(text)}</span>`;
  lab.appendChild(inputEl);
  return lab;
}

function renderTable(){
  const { table } = computeStandings();
  els.tableBody.innerHTML = "";
  let i=1;
  for(const s of table){
    const tr = document.createElement("tr");
    tr.innerHTML = `
      <td>${i++}</td>
      <td><b>${escapeHtml(s.player)}</b></td>
      <td>${s.PJ}</td>
      <td>${s.G}</td>
      <td>${s.P}</td>
      <td>${s.PF}</td>
      <td>${s.PC}</td>
      <td>${s.DIF}</td>
      <td><b>${s.PTS}</b></td>
      <td>${s.bench}</td>
    `;
    els.tableBody.appendChild(tr);
  }
}

function renderStatus(){
  hideStatus();
  const n = state.players.length;
  if(!n) return;

  if(n < 4){
    showStatus("Necesitas m√≠nimo 4 jugadores.", true);
    return;
  }

  if(n % 4 !== 0){
    const need = n % 4;
    showStatus(`No es m√∫ltiplo de 4. Cada ronda descansan <b>${need}</b> jugador(es) (banco rotativo).`, false);
  }
}

function renderAll(){
  renderPlayersBox();
  renderRound();
  renderTable();
  renderStatus();
  els.diagBox.innerHTML = buildDiagnostics();

  els.btnGenR1.disabled = !(state.players.length>=4) || currentRoundNumber()>0;
  els.btnGenNext.disabled = !(state.players.length>=4) || !canGenerateNextRound() || currentRoundNumber()>=MAX_ROUNDS;
}

/* =================== Eventos =================== */
els.btnLoadPlayers.addEventListener("click", ()=>{
  state.players = uniqNonEmptyLines(els.playersInput.value);
  if(state.players.length < 4) return alert("Necesitas m√≠nimo 4 jugadores.");
  saveState();
  renderAll();
});

els.btnGenR1.addEventListener("click", generateRound1);
els.btnGenNext.addEventListener("click", generateNextRound);

els.btnSaveScores.addEventListener("click", ()=>{
  const rn = currentRoundNumber();
  if(rn > 0){
    const ms = matchesInRound(rn);
    for(const m of ms){
      const a = Number(m.ptsA), b = Number(m.ptsB);
      if(!Number.isFinite(a) || !Number.isFinite(b)) return alert("Faltan puntos en alguna mesa.");
      if(a === b) return alert("No se permiten empates. Ajusta los puntos.");
    }
  }
  saveState();
  renderAll();
  alert("Puntos guardados ‚úÖ");
});

els.btnReset.addEventListener("click", resetAll);

els.btnExport.addEventListener("click", ()=>{
  const lines = [];
  lines.push(["round","table","A1","A2","B1","B2","ptsA","ptsB"].join(","));
  for(const m of state.rounds){
    lines.push([m.round,m.table,q(m.A1),q(m.A2),q(m.B1),q(m.B2),m.ptsA??"",m.ptsB??""].join(","));
  }
  lines.push("");
  lines.push("STANDINGS,,,,,,,");
  const { table } = computeStandings();
  lines.push(["rank","player","PJ","G","P","PF","PC","DIF","PTS","bench"].join(","));
  table.forEach((s,i)=>{
    lines.push([i+1,q(s.player),s.PJ,s.G,s.P,s.PF,s.PC,s.DIF,s.PTS,s.bench].join(","));
  });

  const blob = new Blob([lines.join("\n")], {type:"text/csv;charset=utf-8;"});
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href=url; a.download="domino-suizo-2v2-offline-pro.csv";
  document.body.appendChild(a); a.click(); a.remove();
  URL.revokeObjectURL(url);
});
function q(s){
  const t = String(s ?? "");
  if (/[,"\n]/.test(t)) return `"${t.replace(/"/g,'""')}"`;
  return t;
}

/* =================== Init =================== */
loadState();
renderAll();
</script>
</body>
</html>

