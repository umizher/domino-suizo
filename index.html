<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Domin√≥ Suizo (2vs2 Parejas din√°micas)</title>
  <style>
    :root { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial; }
    body { margin: 0; background: #0b1220; color: #e8eefc; }
    header { padding: 16px 18px; background: #121a2b; position: sticky; top: 0; border-bottom: 1px solid #22304f; z-index: 10; }
    header h1 { margin: 0; font-size: 18px; }
    main { padding: 16px 18px; max-width: 1100px; margin: 0 auto; }
    .grid { display: grid; gap: 12px; grid-template-columns: 1fr; }
    @media (min-width: 900px) { .grid { grid-template-columns: 1.1fr 1fr; } }
    .card { background: #121a2b; border: 1px solid #22304f; border-radius: 14px; padding: 14px; }
    .card h2 { margin: 0 0 10px; font-size: 15px; }
    textarea { width: 100%; min-height: 140px; background: #0b1220; color: #e8eefc; border: 1px solid #22304f; border-radius: 10px; padding: 10px; resize: vertical; }
    input, select { background:#0b1220; color:#e8eefc; border:1px solid #22304f; border-radius:10px; padding:8px 10px; }
    .row { display:flex; gap:10px; flex-wrap:wrap; align-items:center; }
    button {
      background: #2b65ff; color: white; border: 0; border-radius: 10px;
      padding: 10px 12px; cursor: pointer; font-weight: 650;
    }
    button.secondary { background:#1b2847; border:1px solid #22304f; }
    button.danger { background:#d12b2b; }
    button:disabled { opacity:.55; cursor:not-allowed; }
    table { width: 100%; border-collapse: collapse; overflow: hidden; border-radius: 12px; }
    th, td { border-bottom: 1px solid #22304f; padding: 10px; text-align: left; font-size: 13px; }
    th { background: #0f1830; } /* SIN sticky para que no tape filas */
    .muted { color:#9fb1db; font-size: 12px; }
    .pill { display:inline-block; padding:3px 8px; border:1px solid #22304f; border-radius:999px; font-size:12px; color:#cfe0ff; }
    .flex-between { display:flex; justify-content:space-between; gap:12px; align-items:center; }
    .matches { display:flex; flex-direction:column; gap:10px; }
    .match {
      border:1px solid #22304f; border-radius:12px; padding:10px; background:#0f1830;
      display:grid; grid-template-columns: 1fr; gap:10px;
    }
    @media (min-width: 750px) { .match { grid-template-columns: 1.6fr 1fr .8fr; } }
    .names { display:flex; flex-direction:column; gap:6px; }
    .line { display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
    .line b { font-size: 14px; }
    .vs { color:#9fb1db; font-size: 12px; margin: 4px 0; }
    .scores { display:flex; gap:10px; align-items:center; justify-content:flex-start; flex-wrap:wrap; }
    .scores label { display:flex; gap:6px; align-items:center; font-size:12px; color:#cfe0ff; }
    .winner { display:flex; align-items:center; justify-content:flex-end; }
    .footer { margin-top: 12px; display:flex; gap:10px; flex-wrap:wrap; align-items:center; }
    .small { font-size: 12px; }
    .notice { padding:10px; border:1px solid #22304f; border-radius:12px; background:#0b1220; }
  </style>
</head>

<body>
<header class="flex-between">
  <h1>üÅ´ Domin√≥ Suizo ‚Äì 2 vs 2 (Parejas din√°micas)</h1>
  <div class="row">
    <span class="pill" id="roundPill">Ronda: 0/5</span>
    <button class="secondary" id="btnExport">Exportar CSV</button>
    <button class="danger" id="btnReset">Reset</button>
  </div>
</header>

<main class="grid">
  <section class="card">
    <h2>Jugadores</h2>
    <p class="muted">Pega <b>un jugador por l√≠nea</b>. Luego: <b>Guardar jugadores</b> ‚Üí <b>Generar Ronda 1</b>.</p>
    <textarea id="playersInput" placeholder="Ej:\nJuan\nPedro\nLuis\nAna\nCarlos\nMiguel\nJos√©\nRa√∫l"></textarea>

    <div class="footer">
      <button id="btnLoadPlayers">Guardar jugadores</button>
      <button class="secondary" id="btnGenR1">Generar Ronda 1 (aleatoria)</button>
      <button class="secondary" id="btnGenNext">Generar Siguiente Ronda (suizo)</button>
      <span class="muted small" id="playersCount"></span>
    </div>

    <div class="notice" style="margin-top:12px;">
      <div class="row">
        <span class="pill">Reglas</span>
        <span class="muted small"><b>5 rondas</b>. <b>No empates</b>. Ranking: <b>Ganadas</b> ‚Üí <b>Puntos</b> ‚Üí <b>DIF</b>.</span>
      </div>
      <div class="row" style="margin-top:8px;">
        <label class="small">Jugadores no m√∫ltiplo de 4 (ej: 30):
          <select id="byeMode">
            <option value="bench" selected>Banco (descansan 1‚Äì3 y NO suman)</option>
            <option value="none">No permitir (solo m√∫ltiplo de 4)</option>
          </select>
        </label>
        <span class="muted small">20: perfecto. 30: descansan 2 por ronda (rotativo).</span>
      </div>
    </div>
  </section>

  <section class="card">
    <div class="flex-between">
      <h2>Ronda actual</h2>
      <div class="row">
        <button id="btnSaveScores">Guardar puntos</button>
      </div>
    </div>
    <div class="matches" id="matches"></div>
    <p class="muted small">Pon puntos por equipo (ej: 200‚Äì120). <b>No se permiten empates</b>.</p>
  </section>

  <section class="card" style="grid-column:1/-1;">
    <div class="flex-between">
      <h2>Tabla (posiciones autom√°ticas)</h2>
      <span class="muted small">Orden: <b>Ganadas</b> ‚Üí <b>Puntos</b> ‚Üí DIF</span>
    </div>
    <div style="overflow:auto; border-radius:12px; border:1px solid #22304f;">
      <table>
        <thead>
          <tr>
            <th>#</th><th>Jugador</th><th>PJ</th><th>G</th><th>P</th><th>Puntos</th><th>En contra</th><th>DIF</th><th>Ganadas</th>
          </tr>
        </thead>
        <tbody id="tableBody"></tbody>
      </table>
    </div>
  </section>
</main>

<script>
/* =================== Config =================== */
const MAX_ROUNDS = 5;

/* =================== Estado + Storage =================== */
const STORAGE_KEY = "domino_suizo_2v2_dynamic_v1";
const state = {
  players: [],
  rounds: [], // {round, table, A1,A2,B1,B2, ptsA, ptsB}
  byeMode: "bench",
  benchHistory: {}, // {player: count}
  _lastBench: null
};

function saveState(){ localStorage.setItem(STORAGE_KEY, JSON.stringify(state)); }
function loadState(){
  const raw = localStorage.getItem(STORAGE_KEY);
  if(!raw) return;
  try{
    const s = JSON.parse(raw);
    if(s && Array.isArray(s.players) && Array.isArray(s.rounds)){
      state.players = s.players;
      state.rounds = s.rounds;
      state.byeMode = s.byeMode || "bench";
      state.benchHistory = s.benchHistory || {};
      state._lastBench = s._lastBench || null;
    }
  }catch{}
}
function resetAll(){
  if(!confirm("¬øSeguro que quieres borrar todo el torneo?")) return;
  state.players = [];
  state.rounds = [];
  state.byeMode = "bench";
  state.benchHistory = {};
  state._lastBench = null;
  saveState();
  renderAll();
}

/* =================== Utilidades =================== */
function uniqNonEmptyLines(text){
  const lines = text.split(/\r?\n/).map(s=>s.trim()).filter(Boolean);
  const seen = new Set();
  const out = [];
  for(const n of lines){
    const k = n.toLowerCase();
    if(!seen.has(k)){ seen.add(k); out.push(n); }
  }
  return out;
}
function shuffle(arr){
  const a = arr.slice();
  for(let i=a.length-1;i>0;i--){
    const j = Math.floor(Math.random()*(i+1));
    [a[i],a[j]]=[a[j],a[i]];
  }
  return a;
}
function pairKey(a,b){ a=String(a); b=String(b); return (a<b)?`${a}|${b}`:`${b}|${a}`; }
function teamKey(a1,a2){ return pairKey(a1,a2); }
function teamsVsKey(tA, tB){ return (tA<tB)?`${tA}||${tB}`:`${tB}||${tA}`; }

function currentRoundNumber(){
  return state.rounds.reduce((m,x)=>Math.max(m,x.round),0);
}
function matchesInRound(rn){
  return state.rounds.filter(m=>m.round===rn).sort((a,b)=>a.table-b.table);
}
function escapeHtml(s){
  return String(s).replace(/[&<>"']/g, m => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#039;'}[m]));
}

/* =================== Standings ===================
   - Ganadas (PTS) es lo principal.
   - Desempate: puntos anotados (PF).
   - Luego DIF.
*/
function computeStandings(){
  const stats = new Map();
  for(const p of state.players){
    stats.set(p,{player:p,PJ:0,G:0,P:0,PF:0,PC:0,DIF:0,PTS:0});
  }

  const teammateUsed = new Set();
  const teamVsUsed = new Set();

  for(const m of state.rounds){
    if(!stats.has(m.A1)||!stats.has(m.A2)||!stats.has(m.B1)||!stats.has(m.B2)) continue;

    const tA = teamKey(m.A1,m.A2);
    const tB = teamKey(m.B1,m.B2);
    teammateUsed.add(tA); teammateUsed.add(tB);
    teamVsUsed.add(teamsVsKey(tA,tB));

    [m.A1,m.A2,m.B1,m.B2].forEach(p=>stats.get(p).PJ++);

    const a = Number(m.ptsA);
    const b = Number(m.ptsB);
    if(!Number.isFinite(a) || !Number.isFinite(b)) continue;
    if(a===b) continue; // sin empates

    if(a>b){
      [m.A1,m.A2].forEach(p=>{ stats.get(p).G++; stats.get(p).PTS++; });
      [m.B1,m.B2].forEach(p=>{ stats.get(p).P++; });
    }else{
      [m.B1,m.B2].forEach(p=>{ stats.get(p).G++; stats.get(p).PTS++; });
      [m.A1,m.A2].forEach(p=>{ stats.get(p).P++; });
    }

    // Puntos anotados/recibidos (desempate por puntos)
    [m.A1,m.A2].forEach(p=>{ stats.get(p).PF += a; stats.get(p).PC += b; });
    [m.B1,m.B2].forEach(p=>{ stats.get(p).PF += b; stats.get(p).PC += a; });
  }

  for(const s of stats.values()) s.DIF = s.PF - s.PC;

  const table = Array.from(stats.values()).sort((x,y)=>{
    if(y.PTS !== x.PTS) return y.PTS - x.PTS; // ganadas
    if(y.PF  !== x.PF ) return y.PF  - x.PF;  // puntos
    if(y.DIF !== x.DIF) return y.DIF - x.DIF; // dif
    return x.player.localeCompare(y.player);
  });

  return { table, teammateUsed, teamVsUsed };
}

/* =================== Validaciones =================== */
function canGenerateNextRound(){
  if(state.players.length < 4) return false;
  const rn = currentRoundNumber();
  if(rn===0) return true;

  const ms = matchesInRound(rn);
  for(const m of ms){
    const a = Number(m.ptsA), b = Number(m.ptsB);
    if(!Number.isFinite(a) || !Number.isFinite(b)) return false;
    if(a===b) return false;
  }
  return true;
}

/* =================== Banco justo (rotativo) =================== */
function pickBench(pool, need){
  const counts = state.benchHistory || {};
  const scored = pool.map(p => ({p, c: (counts[p]||0)}));
  scored.sort((a,b)=>a.c - b.c);
  const bench = [];
  let i=0;
  while(bench.length < need && i < scored.length){
    const minC = scored[i].c;
    const same = [];
    while(i < scored.length && scored[i].c === minC){
      same.push(scored[i].p); i++;
    }
    for(const p of shuffle(same)){
      if(bench.length < need) bench.push(p);
    }
  }
  return bench;
}
function markBench(bench){
  for(const p of bench){
    state.benchHistory[p] = (state.benchHistory[p]||0) + 1;
  }
}

/* =================== Pairing 2vs2 din√°mico =================== */
function generateRound1(){
  if(state.players.length < 4) return alert("Necesitas m√≠nimo 4 jugadores.");
  if(currentRoundNumber() > 0) return alert("Ya hay rondas. Usa 'Generar Siguiente Ronda'.");

  if(state.players.length % 4 !== 0 && state.byeMode === "none"){
    return alert("Para 2vs2 necesitas m√∫ltiplo de 4, o usa Banco.");
  }
  const ranked = shuffle(state.players);
  addNewRoundFromRanked(ranked, true);
}

function generateNextRound(){
  if(currentRoundNumber() >= MAX_ROUNDS) return alert("Ya se jugaron 5 rondas ‚úÖ");
  if(!canGenerateNextRound()) return alert("Completa puntos de la ronda actual (sin empates).");

  if(state.players.length % 4 !== 0 && state.byeMode === "none"){
    return alert("Para 2vs2 necesitas m√∫ltiplo de 4, o usa Banco.");
  }
  const { table, teammateUsed, teamVsUsed } = computeStandings();
  const ranked = table.map(x=>x.player);
  addNewRoundFromRanked(ranked, false, teammateUsed, teamVsUsed);
}

function addNewRoundFromRanked(rankedPlayers, randomize, teammateUsed, teamVsUsed){
  let pool = rankedPlayers.slice();
  if(randomize) pool = shuffle(pool);

  // Banco si sobran 1‚Äì3
  let bench = [];
  if(pool.length % 4 !== 0){
    if(state.byeMode === "bench"){
      const need = pool.length % 4;
      bench = pickBench(pool, need);
      const benchSet = new Set(bench);
      pool = pool.filter(p=>!benchSet.has(p));
      markBench(bench);
    } else return;
  }

  // Formar parejas evitando repetir
  const pairs = [];
  const used = new Set();
  const localTeammateUsed = new Set(teammateUsed || []);

  for(let i=0;i<pool.length;i++){
    const p = pool[i];
    if(used.has(p)) continue;

    let best = null;
    for(let j=i+1;j<pool.length;j++){
      const q = pool[j];
      if(used.has(q)) continue;
      const tk = teamKey(p,q);
      if(!localTeammateUsed.has(tk)){ best = q; break; }
    }
    if(!best){
      for(let j=i+1;j<pool.length;j++){
        const q = pool[j];
        if(!used.has(q)){ best = q; break; }
      }
    }
    if(!best) continue;
    used.add(p); used.add(best);
    const tk = teamKey(p,best);
    pairs.push({p1:p,p2:best, teamKey: tk});
    localTeammateUsed.add(tk);
  }

  // Enfrentar parejas evitando repetir rivales
  const matches = [];
  const usedTeams = new Set();
  const localTeamVsUsed = new Set(teamVsUsed || []);

  for(let i=0;i<pairs.length;i++){
    const A = pairs[i];
    if(usedTeams.has(A.teamKey)) continue;

    let bestOpp = null;
    for(let j=i+1;j<pairs.length;j++){
      const B = pairs[j];
      if(usedTeams.has(B.teamKey)) continue;
      const vk = teamsVsKey(A.teamKey,B.teamKey);
      if(!localTeamVsUsed.has(vk)){ bestOpp = B; break; }
    }
    if(!bestOpp){
      for(let j=i+1;j<pairs.length;j++){
        const B = pairs[j];
        if(!usedTeams.has(B.teamKey)){ bestOpp = B; break; }
      }
    }
    if(!bestOpp) continue;

    usedTeams.add(A.teamKey); usedTeams.add(bestOpp.teamKey);
    localTeamVsUsed.add(teamsVsKey(A.teamKey,bestOpp.teamKey));
    matches.push({A,B:bestOpp});
  }

  const rn = currentRoundNumber()+1;
  let tableNo = 1;
  for(const m of matches){
    state.rounds.push({
      round: rn, table: tableNo++,
      A1:m.A.p1, A2:m.A.p2,
      B1:m.B.p1, B2:m.B.p2,
      ptsA:"", ptsB:""
    });
  }

  state._lastBench = bench.length ? {round: rn, players: bench.slice()} : null;
  saveState();
  renderAll();
}

/* =================== UI =================== */
const els = {
  playersInput: document.getElementById("playersInput"),
  playersCount: document.getElementById("playersCount"),
  matches: document.getElementById("matches"),
  tableBody: document.getElementById("tableBody"),
  roundPill: document.getElementById("roundPill"),
  byeMode: document.getElementById("byeMode"),
  btnLoadPlayers: document.getElementById("btnLoadPlayers"),
  btnGenR1: document.getElementById("btnGenR1"),
  btnGenNext: document.getElementById("btnGenNext"),
  btnSaveScores: document.getElementById("btnSaveScores"),
  btnReset: document.getElementById("btnReset"),
  btnExport: document.getElementById("btnExport")
};

function labelWrap(text, inputEl){
  const lab = document.createElement("label");
  lab.innerHTML = `<span>${escapeHtml(text)}</span>`;
  lab.appendChild(inputEl);
  return lab;
}

function renderPlayersBox(){
  els.playersInput.value = state.players.join("\n");
  els.playersCount.textContent = state.players.length ? `${state.players.length} jugador(es) cargados` : "Sin jugadores cargados";
  els.byeMode.value = state.byeMode;
}
function renderRound(){
  const rn = currentRoundNumber();
  els.roundPill.textContent = `Ronda: ${rn}/${MAX_ROUNDS}`;
  els.matches.innerHTML = "";

  if(rn===0){
    els.matches.innerHTML = `<div class="muted">A√∫n no hay rondas. Presiona <b>Generar Ronda 1</b>.</div>`;
    return;
  }

  const ms = matchesInRound(rn);
  const bench = state._lastBench && state._lastBench.round===rn ? state._lastBench.players : [];

  if(bench && bench.length){
    const d = document.createElement("div");
    d.className = "muted";
    d.style.marginBottom="8px";
    d.innerHTML = `<span class="pill">Banco</span> ${bench.map(escapeHtml).join(", ")} (no suman esta ronda)`;
    els.matches.appendChild(d);
  }

  for(const m of ms){
    const div = document.createElement("div");
    div.className = "match";

    const names = document.createElement("div");
    names.className = "names";
    names.innerHTML = `
      <div class="muted">Mesa ${m.table}</div>
      <div class="line"><span class="pill">A</span> <b>${escapeHtml(m.A1)}</b> + <b>${escapeHtml(m.A2)}</b> <span class="vs">vs</span> <span class="pill">B</span> <b>${escapeHtml(m.B1)}</b> + <b>${escapeHtml(m.B2)}</b></div>
    `;

    const scores = document.createElement("div");
    scores.className = "scores";

    const inpA = document.createElement("input");
    inpA.type="number"; inpA.min="0"; inpA.step="1"; inpA.style.width="90px";
    inpA.value = m.ptsA ?? "";

    const inpB = document.createElement("input");
    inpB.type="number"; inpB.min="0"; inpB.step="1"; inpB.style.width="90px";
    inpB.value = m.ptsB ?? "";

    scores.appendChild(labelWrap("Puntos A", inpA));
    scores.appendChild(labelWrap("Puntos B", inpB));

    const winner = document.createElement("div");
    winner.className = "winner";

    function calcResult(){
      const a = Number(m.ptsA), b = Number(m.ptsB);
      if(!Number.isFinite(a) || !Number.isFinite(b)) return "";
      if(a===b) return "‚ö†Ô∏è Empate NO permitido";
      return (a>b) ? "Gana A" : "Gana B";
    }
    function renderResult(){
      const r = calcResult();
      if(!r) return `<span class="muted">‚Äî</span>`;
      const bad = r.includes("NO permitido");
      return `<span class="pill"${bad?` style="border-color:#d12b2b;color:#ffd0d0"`:""}>Resultado: ${escapeHtml(r)}</span>`;
    }
    winner.innerHTML = renderResult();

    inpA.addEventListener("input", ()=>{ m.ptsA = inpA.value; winner.innerHTML = renderResult(); });
    inpB.addEventListener("input", ()=>{ m.ptsB = inpB.value; winner.innerHTML = renderResult(); });

    div.appendChild(names);
    div.appendChild(scores);
    div.appendChild(winner);
    els.matches.appendChild(div);
  }
}

function renderTable(){
  const { table } = computeStandings();
  els.tableBody.innerHTML = "";
  let i=1;
  for(const s of table){
    const tr = document.createElement("tr");
    tr.innerHTML = `
      <td>${i++}</td>
      <td><b>${escapeHtml(s.player)}</b></td>
      <td>${s.PJ}</td>
      <td>${s.G}</td>
      <td>${s.P}</td>
      <td>${s.PF}</td>
      <td>${s.PC}</td>
      <td>${s.DIF}</td>
      <td><b>${s.PTS}</b></td>
    `;
    els.tableBody.appendChild(tr);
  }
}

function renderAll(){
  renderPlayersBox();
  renderRound();
  renderTable();

  els.btnGenR1.disabled = !(state.players.length>=4) || currentRoundNumber()>0;
  els.btnGenNext.disabled = !(state.players.length>=4) || !canGenerateNextRound() || currentRoundNumber()>=MAX_ROUNDS;
}

/* =================== Eventos =================== */
els.btnLoadPlayers.addEventListener("click", ()=>{
  state.players = uniqNonEmptyLines(els.playersInput.value);
  if(state.players.length < 4) return alert("Necesitas m√≠nimo 4 jugadores.");
  saveState(); renderAll();
});

els.btnGenR1.addEventListener("click", ()=>{
  state.byeMode = els.byeMode.value;
  saveState();
  generateRound1();
});

els.btnGenNext.addEventListener("click", ()=>{
  state.byeMode = els.byeMode.value;
  saveState();
  generateNextRound();
});

els.btnSaveScores.addEventListener("click", ()=>{
  // Validar empates antes de guardar
  const rn = currentRoundNumber();
  if(rn > 0){
    const ms = matchesInRound(rn);
    for(const m of ms){
      const a = Number(m.ptsA), b = Number(m.ptsB);
      if(!Number.isFinite(a) || !Number.isFinite(b)) return alert("Faltan puntos en alguna mesa.");
      if(a === b) return alert("No se permiten empates. Ajusta los puntos.");
    }
  }
  state.byeMode = els.byeMode.value;
  saveState(); renderAll();
  alert("Puntos guardados ‚úÖ");
});

els.btnReset.addEventListener("click", resetAll);

els.btnExport.addEventListener("click", ()=>{
  const lines = [];
  lines.push(["round","table","A1","A2","B1","B2","ptsA","ptsB"].join(","));
  for(const m of state.rounds){
    lines.push([m.round,m.table,q(m.A1),q(m.A2),q(m.B1),q(m.B2),m.ptsA??"",m.ptsB??""].join(","));
  }
  lines.push("");
  lines.push("STANDINGS,,,,,,,");
  const { table } = computeStandings();
  lines.push(["rank","player","PJ","G","P","PF","PC","DIF","PTS"].join(","));
  table.forEach((s,i)=>{
    lines.push([i+1,q(s.player),s.PJ,s.G,s.P,s.PF,s.PC,s.DIF,s.PTS].join(","));
  });

  const blob = new Blob([lines.join("\n")], {type:"text/csv;charset=utf-8;"});
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href=url; a.download="domino-suizo-2v2.csv";
  document.body.appendChild(a); a.click(); a.remove();
  URL.revokeObjectURL(url);
});
function q(s){
  const t = String(s ?? "");
  if (/[,"\n]/.test(t)) return `"${t.replace(/"/g,'""')}"`;
  return t;
}

/* =================== Init =================== */
loadState();
renderAll();
</script>
</body>
</html>

